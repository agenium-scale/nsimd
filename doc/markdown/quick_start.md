<!--

Copyright (c) 2019 Agenium Scale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->

# Quick Start

This is a quick start guide for `nsimd`. Its purpose is to get you ready to go
by learning how to install `nsimd` and its dependencies, and how to compile a
simple `nsimd` program.


##  Dependencies

@[INCLUDE](compilers_and_versions.md)

The library should be built with
[CMake](https://gitlab.kitware.com/cmake/cmake) on GNU/Linux and Windows.

Generating C and C++ files is done by the Python3 code contained in the `egg`.
Python should be installed by default on any GNU/Linux distribution. On Windows
it comes with the latest versions of Visual Studio on Windows
(<https://visualstudio.microsoft.com/vs/community/>), you can also download and
install it directly from <https://www.python.org/>.

The Python code calls `clang-format` to properly format all generated C and C++
source. On GNU/Linux you can install it via your package manager. On Windows you
can use the official binary at <https://llvm.org/builds/>.

Testing the library requires the Google Test library that can be found at
<https://github.com/google/googletest> and the MPFR library that can be found at
<https://www.mpfr.org/>.

Benchmarking the library requires Google Benchmark version 1.3 that can be
found at <https://github.com/google/benchmark> plus all the other SIMD
libraries used for comparison:
- MIPP (<https://github.com/aff3ct/MIPP>)
- Sleef (<https://sleef.org/>)

Compiling the library requires a C++14 compiler. Any recent version of GCC,
Clang and MSVC will do. Note that the produced library and header files for the
end-user are C89, C++98, C++11 compatible. Note that C and C++ files are
generated by a bunch of Python scripts and they must be executed first before
running CMake.


## Building `nsimd`

### Building `nsimd` for GNU/Linux

The installation of `nsimd` is done by retrieving the current status of the
library by cloning the repository. This is done via the following command:
@[INCLUDE_CODE:L24:L24](../src/nsimd.sh)

Generating C and C++ files using Python3:
@[INCLUDE_CODE:L28:L29](../src/nsimd.sh)

Build `nsimd`:
@[INCLUDE_CODE:L31:L35](../src/nsimd.sh)

You can set the target architecture using the `-DSIMD=<simd>` option for CMake:
@[INCLUDE_CODE:L37:L45](../src/nsimd.sh)

Some SIMD instructions are optional. FMA (Fused Multiply-Add) can be enabled
using the option `-DSIMD_OPTIONALS=<simd-optional>...`:
@[INCLUDE_CODE:L47:L52](../src/nsimd.sh)

The generated sources might be big, using `ninja` over `make` is generally
better. To use `ninja`, call CMAKE with `-GNinja` option.

### Building `nsimd` for Windows

Make sure you are typing in a Visual Studio prompt. We give examples with
`ninja`. We also explicitely specify the MSVC compiler. Note that you can
use the latest versions of Visual Studio to build the library using its
`CMakeLists.txt`.

```Bash
python egg\hatch.py -Af
md build
cd build
cmake .. -GNinja -DCMAKE_C_COMPILER=cl -DCMAKE_CXX_COMPILER=cl
ninja
```

You can also set the SIMD instruction using the `-DSIMD=<simd>` option when
generating with cmake like:

```Bash
REM Enable AVX2 support for nsimd
cmake .. -DSIMD=AVX2 -GNinja -DCMAKE_C_COMPILER=cl -DCMAKE_CXX_COMPILER=cl
ninja
```

Some SIMD instructions are optional like for FMA (Fused Multiply-Add), you
can enable them using the option `-DSIMD_OPTIONALS=<simd-optional>...`:

```Bash
REM Enable AVX2 with FMA support for nsimd
cmake .. -DSIMD=AVX2 -DSIMD_OPTIONALS=FMA -GNinja -DCMAKE_C_COMPILER=cl -DCMAKE_CXX_COMPILER=cl
ninja
```

### Building benches

Benches are not built by default when invoking CMake. To enable them define
the CMake variable `ENABLE_BENCHMARK`.

```Bash
cmake [...] -DENABLE_BENCHMARK=on
```

Note that third party libraries are required to perform benches as described
above. If those cannot be found in standard system paths then you can tell
CMake where they are located using the following CMake variables.

| Dependency       | CMake variable                                        |
|------------------|-------------------------------------------------------|
| Sleef            | `cmake [...] -DSleef_ROOT_DIR=/path/to/sleef`         |
| MIPP             | `cmake [...] -DMIPP_ROOT_DIR=/path/to/MIPP`           |
| Google benchmark | `cmake [...] -Dbenchmark_ROOT_DIR=/path/to/benchmark` |

You can also use a script that pulls out every required dependencies and build
them at the top-level git directory:

```Bash
./scripts/init-benches-deps.sh
```

Every dependencies will be installed in the `_install` directory.

You can then use the following special command for cmake:
```CMake
## Assume your building under a `build` directory
cmake [...] -DCMAKE_LIBRARY_PATH="$(pwd)/../_install/lib" -DCMAKE_INCLUDE_PATH="$(pwd)/../_install/include" -DENABLE_BENCHMARK=on
```


## Compiling and Running a Program using `nsimd`

<!-- TODO -->

### Compiling for GNU/Linux

`nsimd` can be compiled on GNU/Linux using `g++`, `clang` or `icc`. To compile
a program using `nsimd`, use your compiler as usual and adds the `BOOST_ROOT`
and `BOOST_SIMD_ROOT` path along with the SIMD extensions flags of your choices.

For example:
```Bash
g++ my_code.cpp -O3 -DNDEBUG -o my_code -I$BOOST_ROOT -I$BOOST_SIMD_ROOT -mavx
```
Refer to your compiler user's manual to find the proper flag to use to trigger a
given SIMD extension support.

### Compiling for Windows

The recommended compiler on Windows is Visual Studio. To compile a program using
`nsimd`, add the `BOOST_ROOT` and `BOOST_SIMD_ROOT` path to your project
settings.

Contrary to other compilers, Visual Studio only recognize SSE, AVX and AVX2 are
specific SIMD targets. To enable `nsimd` supports for other architecture, you
need to set a specific preprocessor symbol.

When using AVX or AVX2, you may want to enable support for SSE4.2 to ensure
maximal performance from AVX code using SSE intrinsics.

NOTE:  
Visual Studio provides a `\Gv` settings that enables a special calling
convention called `__vectorcall` that try to use SIMD registers when passing
SIMD values as function parameters. Its effect in conjunction with `nsimd`
depends on the code. Feel free to try it and use it if it improves your
performances.

### Compiling using `CMake`

`nsimd` can be used along with `CMake` using `find_package`:
```CMake
## CMake requirements
cmake_minimum_required(VERSION 2.8)

## Look for installed Boost.SIMD
find_package(Boost.SIMD)

## Add Boost.SIMD directories to tell CMake where to find them
include_directories(${"Boost.SIMD@_INCLUDE_DIRS"})

## Create your executable
add_executable(foobar foobar.cpp)
```

`nsimd` MUST BE installed on your system, otherwise `find_package` won't be able
to find it. Please refer to the `CMake`'s documentation for more details about
`find_package`.

NOTE:  
You can modify the `CMAKE_MODULE_PATH` to help `CMake` find your `nsimd` if you
installed it on a different folder than the default ones.


## Building and Running `nsimd` Tests

`nsimd` provides a large set of unit tests and benchmarks. Due to their sheer
numbers, their compilation must be opted-in. This can be done by setting the
DEV symbol when configuring `nsimd`'s `CMake`. 
```
cmake path/to/source -DBOOST_ROOT=path/to/boost -DDEV=1
```
If the tests are successfully enabled, the `CMake` log should inform you:
```CMake
-- ## -----------------------------------------------------------------------------
--    Unit and performances tests are available.
--    Please run the update targets to install pre-requisites:
--        make -j1 update / ninja -j1 update
-- ## -----------------------------------------------------------------------------
```
Proceed to update your local build by issuing one of the proposed command. Once
the test and benchmark libraries are set up, you can use the unit, exhaustive or
bench targets to build all unit tests, precision tests or benchmarks. Single
function test or benchmark can be compiled by using the hierarchical target
name. For example, the unit test for the SIMD version of function plus is
compilable via:
```Bash
make function.simd.plus.unit
```


## What's Next?

You can now:
- [Have a look at some of our tutorials](tutorials.md)
- [Browse the Reference Documentation](api.md)
If you encounter any problems or think you found bug, you can:
- [Consult the FAQ](faq.md)
- [Consult our Issues Tracker on GitHub](https://github.com/agenium-scale/nsimd/issues)
