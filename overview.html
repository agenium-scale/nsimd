<!--

Copyright (c) 2021 Agenium Scale

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->

<!-- This file has been auto-generated -->

<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>NSIMD documentation</title>
    <style type="text/css">
      body {
        /*margin:40px auto;*/
        margin:10px auto;
        /*max-width:650px;*/
        max-width:800px;
        /*line-height:1.6;*/
        line-height:1.4;
        /*font-size:18px;*/
        color:#444;
        padding: 0 10px;
      }
      h1,h2,h3 {
        line-height: 1.2;
      }
      table {
        border-collapse: collapse;
        border: 0px solid gray;
        width: 100%;
      }
      th, td {
        border: 2px solid gray;
        padding: 0px 1em 0px 1em;
      }
    </style>
    <!-- https://www.mathjax.org/#gettingstarted -->
    <script src="assets/polyfill.min.js"></script>
    <script id="MathJax-script" async src="assets/tex-svg.js"></script>
    <!-- Highlight.js -->
    <link rel="stylesheet" href= "assets/highlight.js.default.min.css">
    <script src="assets/highlight.min.js"></script>
    <script src="assets/cpp.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
<body>

<div style="text-align: center; margin-bottom: 1em;">
  <img src="img/logo.svg">
  <hr>
</div>
<div style="text-align: center; margin-bottom: 1em;">
  <b>NSIMD documentation</b>
</div>
<div style="text-align: center; margin-bottom: 1em;">
  <a href="index.html">Index</a> |
  <a href="tutorial.html">Tutorial</a> |
  <a href="faq.html">FAQ</a> |
  <a href="contribute.html">Contribute</a> |
  <a href="overview.html">API overview</a> |
  <a href="api.html">API reference</a> |
  <a href="wrapped_intrinsics.html">Wrapped intrinsics</a> |
  <a href="modules.html">Modules</a>
  <hr>
</div>

<h1>Overview</h1>
<h2>NSIMD scalar types</h2>
<p>Their names follow the following pattern: <code>Sxx</code> where</p>
<ul>
<li><p><code>S</code> is <code>i</code> for signed integers, <code>u</code> for unsigned integer or <code>f</code> for
floatting point number.</p></li>
<li><p><code>xx</code> is the number of bits taken to represent the number.</p></li>
</ul>
<p>Full list of scalar types:</p>
<ul>
<li><p><code>f64</code></p></li>
<li><p><code>f32</code></p></li>
<li><p><code>f16</code></p></li>
<li><p><code>i64</code></p></li>
<li><p><code>i32</code></p></li>
<li><p><code>i16</code></p></li>
<li><p><code>i8</code></p></li>
<li><p><code>u64</code></p></li>
<li><p><code>u32</code></p></li>
<li><p><code>u16</code></p></li>
<li><p><code>u8</code></p></li>
</ul>
<h2>NSIMD generic SIMD vector types</h2>
<p>In NSIMD, we call a platform an architecture e.g. Intel, ARM, POWERPC. We call
SIMD extension a set of low-level functions and types provided by hardware
vendors to access SIMD units. Examples include SSE2, SSE42, AVX, ...  When
compiling the generic SIMD vector types represents a SIMD register of the
target. Examples are a <code>__m128</code> for Intel SSE, <code>__m512</code> for Intel AVX-512 or
<code>svfloat32_t</code> for Arm SVE.</p>
<p>Their names follow the following pattern:</p>
<ul>
<li><p>C base API: <code>vSCALAR</code> where <code>SCALAR</code> is a one of scalar type listed above.</p></li>
<li><p>C advanced API: <code>nsimd_pack_SCALAR</code> where <code>SCALAR</code> is a one of scalar type
listed above.</p></li>
<li><p>C++ advanced API: <code>nsimd::pack&lt;SCALAR&gt;</code> where <code>SCALAR</code> is a one of scalar
type listed above.</p></li>
</ul>
<p>Full list of SIMD vector types:</p>
<table>
<thead>
<tr>
<th style="text-align: left;">Base type</th>
<th style="text-align: left;">C base API</th>
<th style="text-align: left;">C advanced API</th>
<th style="text-align: left;">C++ advanced API</th>
</tr>
</thead><tbody>
<tr>
<td style="text-align: left;"><code>f64</code></td>
<td style="text-align: left;"><code>vf64</code></td>
<td style="text-align: left;"><code>nsimd_pack_f64</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;f64&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>f32</code></td>
<td style="text-align: left;"><code>vf32</code></td>
<td style="text-align: left;"><code>nsimd_pack_f32</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;f32&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>f16</code></td>
<td style="text-align: left;"><code>vf16</code></td>
<td style="text-align: left;"><code>nsimd_pack_f16</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;f16&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>i64</code></td>
<td style="text-align: left;"><code>vi64</code></td>
<td style="text-align: left;"><code>nsimd_pack_i64</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;i64&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>i32</code></td>
<td style="text-align: left;"><code>vi32</code></td>
<td style="text-align: left;"><code>nsimd_pack_i32</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;i32&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>i16</code></td>
<td style="text-align: left;"><code>vi16</code></td>
<td style="text-align: left;"><code>nsimd_pack_i16</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;i16&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>i8</code></td>
<td style="text-align: left;"><code>vi8</code></td>
<td style="text-align: left;"><code>nsimd_pack_i8</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;i8&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>u64</code></td>
<td style="text-align: left;"><code>vu64</code></td>
<td style="text-align: left;"><code>nsimd_pack_u64</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;u64&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>u32</code></td>
<td style="text-align: left;"><code>vu32</code></td>
<td style="text-align: left;"><code>nsimd_pack_u32</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;u32&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>u16</code></td>
<td style="text-align: left;"><code>vu16</code></td>
<td style="text-align: left;"><code>nsimd_pack_u16</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;u16&gt;</code></td>
</tr>
<tr>
<td style="text-align: left;"><code>u8</code></td>
<td style="text-align: left;"><code>vu8</code></td>
<td style="text-align: left;"><code>nsimd_pack_u8</code></td>
<td style="text-align: left;"><code>nsimd::pack&lt;u8&gt;</code></td>
</tr>
</tbody>
</table>
<h2>C/C++ base APIs</h2>
<p>These come automatically when you include <code>nsimd/nsimd.h</code>. You do <em>not</em> need
to include a header file for having a function. Here is a list of supported
platforms and their corresponding SIMD extensions.</p>
<ul>
<li><p>Platform <code>arm</code></p><ul>
<li><p><code>neon128</code></p></li>
<li><p><code>aarch64</code></p></li>
<li><p><code>sve</code></p></li>
<li><p><code>sve128</code></p></li>
<li><p><code>sve256</code></p></li>
<li><p><code>sve512</code></p></li>
<li><p><code>sve1024</code></p></li>
<li><p><code>sve2048</code></p></li>
</ul>
</li>
<li><p>Platform <code>x86</code></p><ul>
<li><p><code>sse2</code></p></li>
<li><p><code>sse42</code></p></li>
<li><p><code>avx</code></p></li>
<li><p><code>avx2</code></p></li>
<li><p><code>avx512_knl</code></p></li>
<li><p><code>avx512_skylake</code></p></li>
</ul>
</li>
<li><p>Platform <code>ppc</code></p><ul>
<li><p><code>vmx</code></p></li>
<li><p><code>vsx</code></p></li>
</ul>
</li>
<li><p>Platform <code>cpu</code></p><ul>
<li><p><code>cpu</code></p></li>
</ul>
</li>
</ul>
<p>Each simd extension has its own set of SIMD types and functions. Types follow
the pattern: <code>nsimd_SIMDEXT_vSCALAR</code> where</p>
<ul>
<li><p><code>SIMDEXT</code> is the SIMD extensions.</p></li>
<li><p><code>SCALAR</code> is one of scalar types listed above.</p></li>
</ul>
<p>There are also logical types associated to each SIMD vector type. These types
are used, for example, to represent the result of a comparison of SIMD vectors.
They are usually bit masks. Their name follow the pattern:
<code>nsimd_SIMDEXT_vlSCALAR</code> where</p>
<ul>
<li><p><code>SIMDEXT</code> is the SIMD extensions.</p></li>
<li><p><code>SCALAR</code> is one of scalar types listed above.</p></li>
</ul>
<p>Note 1: Platform <code>cpu</code> is a 128 bits SIMD emulation fallback when no SIMD
extension has been specified or is supported on a given compilation target.</p>
<p>Note 2: as all SIMD extensions of all platforms are different there is no
need to put the name of the platform in each identifier.</p>
<p>Function names follow the pattern: <code>nsimd_SIMDEXT_FUNCNAME_SCALAR</code> where</p>
<ul>
<li><p><code>SIMDEXT</code> is the SIMD extensions.</p></li>
<li><p><code>FUNCNAME</code> is the name of a function e.g. <code>add</code> or <code>sub</code>.</p></li>
<li><p><code>SCALAR</code> is one of scalar types listed above.</p></li>
</ul>
<h3>Generic identifier</h3>
<p>In the base C API, genericity is achieved using macros.</p>
<ul>
<li><p><code>vec(SCALAR)</code> is a type to represent a SIMD vector containing SCALAR
elements.  SCALAR must be one of scalar types listed above.</p></li>
<li><p><code>vecl(SCALAR)</code> is a type to represent a SIMD vector of logicals for SCALAR
elements. SCALAR must be one of scalar types listed above.</p></li>
<li><p><code>vec_a(SCALAR, SIMDEXT)</code> is a type to represent a SIMD vector containing
SCALAR elements for the simd extension SIMDEXT. SCALAR must be one of scalar
types listed above and SIMDEXT must be a valid SIMD extension.</p></li>
<li><p><code>vecl_a(SCALAR, SIMDEXT)</code> is a type to represent a SIMD vector of logicals
for SCALAR elements for the simd extension SIMDEXT. SCALAR must be one of
scalar types listed above and SIMDEXT must be a valid SIMD extension.</p></li>
<li><p><code>vFUNCNAME</code> takes as input the above types to access the operator FUNCNAME
e.g. <code>vadd</code>, <code>vsub</code>.</p></li>
</ul>
<p>In C++98 and C++03, type traits are available.</p>
<ul>
<li><p><code>nsimd::simd_traits&lt;SCALAR, SIMDEXT&gt;::vector</code> is the SIMD vector type for
platform SIMDEXT containing SCALAR elements. SIMDEXT is one of SIMD
extension listed above, SCALAR is one of scalar type listed above.</p></li>
<li><p><code>nsimd::simd_traits&lt;SCALAR, SIMDEXT&gt;::vectorl</code> is the SIMD vector of logicals
type for platform SIMDEXT containing SCALAR elements. SIMDEXT is one of
SIMD extensions listed above, SCALAR is one of scalar type listed above.</p></li>
</ul>
<p>In C++11 and beyond, type traits are still available but typedefs are also
provided.</p>
<ul>
<li><p><code>nsimd::vector&lt;SCALAR, SIMDEXT&gt;</code> is a typedef to
<code>nsimd::simd_traits&lt;SCALAR, SIMDEXT&gt;::vector</code>.</p></li>
<li><p><code>nsimd::vectorl&lt;SCALAR, SIMDEXT&gt;</code> is a typedef to
<code>nsimd::simd_traits&lt;SCALAR, SIMDEXT&gt;::vectorl</code>.</p></li>
</ul>
<p>The C++20 API does not bring different types for SIMD registers nor other
way to access the other SIMD types. It only brings concepts instead of usual
<code>typename</code>s. For more informations cf. <a href="concepts.html">concepts.md</a>.</p>
<p>Note that all macro and functions available in plain C are still available in
C++.</p>
<h3>List of operators provided by the base APIs</h3>
<p>In the documentation we use interchangeably the terms &quot;function&quot; and
&quot;operator&quot;.  For each operator FUNCNAME a C function (also available in C++)
named <code>nsimd_SIMDEXT_FUNCNAME_SCALAR</code> is available for each SCALAR type unless
specified otherwise.</p>
<p>For each FUNCNAME, a C macro (also available in C++) named <code>vFUNCNAME</code> is
available and takes as its last argument a SCALAR type.</p>
<p>For each FUNCNAME, a C macro (also available in C++) named <code>vFUNCNAME_a</code> is
available and takes as its two last argument a SCALAR type and a SIMDEXT.</p>
<p>For each FUNCNAME, a C++ function in namespace <code>nsimd</code> named <code>FUNCNAME</code> is
available. It takes as its last argument the SCALAR type and can optionnally
take the SIMDEXT as its last last argument.</p>
<p>For example, for the addition of two SIMD vectors <code>a</code> and <code>b</code> here are the
possibilities:</p>
<pre class="c++"><code>c = nsimd_add_avx_f32(a, b); // use AVX
c = nsimd::add(a, b, f32()); // use detected SIMDEXT
c = nsimd::add(a, b, f32(), avx()); // force AVX even if detected SIMDEXT is not AVX
c = vadd(a, b, f32); // use detected SIMDEXT
c = vadd_e(a, b, f32, avx); // force AVX even if detected SIMDEXT is not AVX</code></pre>
<p>Here is a list of available FUNCNAME.</p>
<ul>
<li><p><code>int len();</code><br></p></li>
<li><p><code>vSCALAR set1(SCALAR a0);</code><br></p></li>
<li><p><code>vlSCALAR set1l(int a0);</code><br></p></li>
<li><p><code>vSCALAR loadu(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALAR masko_loadu1(vlSCALAR a0, SCALAR const* a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR maskz_loadu1(vlSCALAR a0, SCALAR const* a1);</code><br></p></li>
<li><p><code>vSCALARx2 load2u(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALARx3 load3u(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALARx4 load4u(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALAR loada(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALAR masko_loada1(vlSCALAR a0, SCALAR const* a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR maskz_loada1(vlSCALAR a0, SCALAR const* a1);</code><br></p></li>
<li><p><code>vSCALARx2 load2a(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALARx3 load3a(SCALAR const* a0);</code><br></p></li>
<li><p><code>vSCALARx4 load4a(SCALAR const* a0);</code><br></p></li>
<li><p><code>vlSCALAR loadlu(SCALAR const* a0);</code><br></p></li>
<li><p><code>vlSCALAR loadla(SCALAR const* a0);</code><br></p></li>
<li><p><code>void storeu(SCALAR* a0, vSCALAR a1);</code><br></p></li>
<li><p><code>void mask_storeu1(vlSCALAR a0, SCALAR* a1, vSCALAR a2);</code><br></p></li>
<li><p><code>void store2u(SCALAR* a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>void store3u(SCALAR* a0, vSCALAR a1, vSCALAR a2, vSCALAR a3);</code><br></p></li>
<li><p><code>void store4u(SCALAR* a0, vSCALAR a1, vSCALAR a2, vSCALAR a3, vSCALAR a4);</code><br></p></li>
<li><p><code>void storea(SCALAR* a0, vSCALAR a1);</code><br></p></li>
<li><p><code>void mask_storea1(vlSCALAR a0, SCALAR* a1, vSCALAR a2);</code><br></p></li>
<li><p><code>void store2a(SCALAR* a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>void store3a(SCALAR* a0, vSCALAR a1, vSCALAR a2, vSCALAR a3);</code><br></p></li>
<li><p><code>void store4a(SCALAR* a0, vSCALAR a1, vSCALAR a2, vSCALAR a3, vSCALAR a4);</code><br></p></li>
<li><p><code>vSCALAR gather(SCALAR const* a0, viCALAR a1);</code><br>
Only available for f64, f32, f16, i16, u16, u32, i32, i64, u64</p></li>
<li><p><code>vSCALAR gather_linear(SCALAR const* a0, int a1);</code><br></p></li>
<li><p><code>void scatter(SCALAR* a0, viCALAR a1, vSCALAR a2);</code><br>
Only available for f64, f32, f16, i16, u16, u32, i32, i64, u64</p></li>
<li><p><code>void scatter_linear(SCALAR* a0, int a1, vSCALAR a2);</code><br></p></li>
<li><p><code>void storelu(SCALAR* a0, vlSCALAR a1);</code><br></p></li>
<li><p><code>void storela(SCALAR* a0, vlSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR orb(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR andb(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR andnotb(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR notb(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR xorb(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR orl(vlSCALAR a0, vlSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR andl(vlSCALAR a0, vlSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR andnotl(vlSCALAR a0, vlSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR xorl(vlSCALAR a0, vlSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR notl(vlSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR add(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR sub(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>SCALAR addv(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR mul(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR div(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR neg(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR min(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR max(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR shr(vSCALAR a0, int a1);</code><br>
Only available for i64, i32, i16, i8, u64, u32, u16, u8</p></li>
<li><p><code>vSCALAR shl(vSCALAR a0, int a1);</code><br>
Only available for i64, i32, i16, i8, u64, u32, u16, u8</p></li>
<li><p><code>vSCALAR shra(vSCALAR a0, int a1);</code><br>
Only available for i64, i32, i16, i8, u64, u32, u16, u8</p></li>
<li><p><code>vlSCALAR eq(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR ne(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR gt(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR ge(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR lt(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vlSCALAR le(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR if_else1(vlSCALAR a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR abs(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR fma(vSCALAR a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR fnma(vSCALAR a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR fms(vSCALAR a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR fnms(vSCALAR a0, vSCALAR a1, vSCALAR a2);</code><br></p></li>
<li><p><code>vSCALAR ceil(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR floor(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR trunc(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR round_to_even(vSCALAR a0);</code><br></p></li>
<li><p><code>int all(vlSCALAR a0);</code><br></p></li>
<li><p><code>int any(vlSCALAR a0);</code><br></p></li>
<li><p><code>int nbtrue(vlSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR reinterpret(vSCALAR a0);</code><br></p></li>
<li><p><code>vlSCALAR reinterpretl(vlSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR cvt(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALARx2 upcvt(vSCALAR a0);</code><br>
Only available for i8, u8, i16, u16, f16, i32, u32, f32</p></li>
<li><p><code>vSCALAR downcvt(vSCALAR a0, vSCALAR a1);</code><br>
Only available for i16, u16, f16, i32, u32, f32, i64, u64, f64</p></li>
<li><p><code>vSCALAR rec(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR rec11(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR rec8(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR sqrt(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR rsqrt11(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR rsqrt8(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR ziplo(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR ziphi(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR unziplo(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR unziphi(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALARx2 zip(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALARx2 unzip(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR to_mask(vlSCALAR a0);</code><br></p></li>
<li><p><code>vlSCALAR to_logical(vSCALAR a0);</code><br></p></li>
<li><p><code>vSCALAR iota();</code><br></p></li>
<li><p><code>vlSCALAR mask_for_loop_tail(int a0, int a1);</code><br></p></li>
<li><p><code>vSCALAR adds(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR subs(vSCALAR a0, vSCALAR a1);</code><br></p></li>
<li><p><code>vSCALAR sin_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cos_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR tan_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR asin_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR acos_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR atan_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR atan2_u35(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR log_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cbrt_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR sin_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cos_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR tan_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR asin_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR acos_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR atan_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR atan2_u10(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR log_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cbrt_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR exp_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR pow_u10(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR sinh_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cosh_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR tanh_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR sinh_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cosh_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR tanh_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR asinh_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR acosh_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR atanh_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR exp2_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR exp2_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR exp10_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR exp10_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR expm1_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR log10_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR log2_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR log2_u35(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR log1p_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR sinpi_u05(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR cospi_u05(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR hypot_u05(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR hypot_u35(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR remainder(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR fmod(vSCALAR a0, vSCALAR a1);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR lgamma_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR tgamma_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR erf_u10(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
<li><p><code>vSCALAR erfc_u15(vSCALAR a0);</code><br>
Only available for f64, f32, f16</p></li>
</ul>
<h2>C advanced API (only available in C11)</h2>
<p>The C advanced API takes advantage of the C11 <code>_Generic</code> keyword to provide
function overloading. Unlike the base API described above there is no need to
pass as arguments the base type of the SIMD extension. The informations are
contained in the types provided by this API.</p>
<ul>
<li><p><code>nsimd_pack_SCALAR_SIMDEXT</code> represents a SIMD vectors containing
SCALAR elements of SIMD extension SIMDEXT.</p></li>
<li><p><code>nsimd::packl_SCALAR_SIMDEXT</code> represents a SIMD vectors of logicals
for SCALAR elements of SIMD extension SIMDEXT.</p></li>
</ul>
<p>There are versions of the above type without SIMDEXT for which the targeted
SIMD extension is automatically chosen.</p>
<ul>
<li><p><code>nsimd_pack_SCALAR</code> represents a SIMD vectors containing SCALAR elements.</p></li>
<li><p><code>nsimd::packl_SCALAR</code> represents a SIMD vectors of logicals for SCALAR
elements.</p></li>
</ul>
<p>Generic types are also available:</p>
<ul>
<li><p><code>nsimd_pack(SCALAR)</code> is a type to represent a SIMD vector containing SCALAR
elements.  SCALAR must be one of scalar types listed above.</p></li>
<li><p><code>nsimd_packl(SCALAR)</code> is a type to represent a SIMD vector of logicals for
SCALAR elements. SCALAR must be one of scalar types listed above.</p></li>
<li><p><code>nsimd_pack_a(SCALAR, SIMDEXT)</code> is a type to represent a SIMD vector
containing SCALAR elements for the simd extension SIMDEXT. SCALAR must be one
of scalar types listed above and SIMDEXT must be a valid SIMD extension.</p></li>
<li><p><code>nsimd_packl_a(SCALAR, SIMDEXT)</code> is a type to represent a SIMD vector of
logicals for SCALAR elements for the simd extension SIMDEXT. SCALAR must be
one of scalar types listed above and SIMDEXT must be a valid SIMD extension.</p></li>
</ul>
<p>Finally, operators are follow the naming: <code>nsimd_FUNCNAME</code> e.g. <code>nsimd_add</code>,
<code>nsimd_sub</code>.</p>
<h2>C++ advanced API</h2>
<p>The C++ advanced API is called advanced not because it requires C++11 or above
but because it makes use of the particular implementation of ARM SVE by ARM
in their compiler. We do not know if GCC (and possibly MSVC in the distant
future) will use the same approach. Anyway the current implementation allows
us to put SVE SIMD vectors inside some kind of structs that behave like
standard structs. If you want to be sure to write portable code do <em>not</em> use
this API. Two new types are available.</p>
<ul>
<li><p><code>nsimd::pack&lt;SCALAR, N, SIMDEXT&gt;</code> represents <code>N</code> SIMD vectors containing
SCALAR elements of SIMD extension SIMDEXT. You can specify only the first
template argument. The second defaults to 1 while the third defaults to the
detected SIMDEXT.</p></li>
<li><p><code>nsimd::packl&lt;SCALAR, N, SIMDEXT&gt;</code> represents <code>N</code> SIMD vectors of logical
type containing SCALAR elements of SIMD extension SIMDEXT. You can specify
only the first template argument. The second defaults to 1 while the third
defaults to the detected SIMDEXT.</p></li>
</ul>
<p>Use N &gt; 1 when declaring packs to have an unroll of N. This is particularily
useful on ARM.</p>
<p>Functions that takes packs do not take any other argument unless specified
otherwise e.g. the load family of funtions. It is impossible to determine
the kind of pack (unroll and SIMDEXT) from the type of a pointer. Therefore
in this case, the last argument must be a pack and this same type will then
return. Also some functions are available as C++ operators. They follow the
naming: <code>nsimd::FUNCNAME</code>.</p>
  </body>
</html>
